<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:商业化部署</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 id="1-">1.需求分析</h1>
<p>靠谱的商用项目不是只有一个可执行程序就够了的。好的商用项目应该遵守的原则：</p>
<ul>
<li>客户端（方便使用）：启动器，安装包等</li>
<li>服务器（方便部署和扩展）：依赖库，启动脚本等</li>
</ul>
<p><strong>需求原型：</strong></p>
<ul>
<li>用户注册，登陆</li>
<li>建房</li>
<li>跟房</li>
</ul>
<p><img src="商业化部署.assets/1560849263612.png" alt="1560849263612"></p>
<ul>
<li>登陆服务器：管理当前的游戏服务器</li>
<li>登陆客户端：提供登陆注册和建房跟房界面（简单的qt编程）</li>
<li>游戏服务器：内容不用动，但要部署多份。</li>
</ul>
<h2 id="1-1-1-">1.1方案1（多主机或虚拟机）</h2>
<ul>
<li>登陆服务器<ul>
<li>记录当前启动游戏服务器的服务器IP或主机名</li>
<li>向登陆客户端返回IP或主机名</li>
<li>管理这些主机的状态（启动，停止。，更新）</li>
</ul>
</li>
<li>登陆客户端：通过房号查找游戏服务所在的计算机IP</li>
<li><p>游戏服务器：每个主机或虚拟机启动一个。</p>
<p><strong>优点：</strong> 游戏服务器部署简单，测试简单，跟单个服务器的操作完全相同。</p>
</li>
</ul>
<p><strong>缺点：</strong> 登陆服务器的业务复杂，不好维护游戏服务器所在的诸多主机。</p>
<h2 id="1-2-2-">1.2方案2（多进程）</h2>
<ul>
<li>登陆服务器<ul>
<li>记录当前启动的游戏服务器的端口号</li>
<li>向登陆客户端返回端口号</li>
<li>管理启动的游戏服务器进程</li>
</ul>
</li>
<li>登陆客户端：向登陆服务器获取游戏服务器端口号</li>
<li>游戏服务器：<ul>
<li>支持端口可配</li>
<li>增加多份除进程之外的资源（数据库，日志文件等）</li>
<li>保护对公共资源的访问</li>
</ul>
</li>
</ul>
<p><strong>优点：</strong> 登陆服务器实现简单，只需要要简单的进程管理即可</p>
<p><strong>缺点：</strong> 游戏服务器的职责变的复杂（增加信号量集等进程间通信），而且不好管理（相同的文件或数据库存在多份）</p>
<h2 id="1-3-3-">1.3方案3（容器化）</h2>
<ul>
<li>登陆服务器<ul>
<li>记录当前启动的游戏服务器的端口号</li>
<li>向登陆客户端返回端口号</li>
<li>管理启动的游戏服务器所在容器</li>
</ul>
</li>
<li>登陆客户端：向登陆服务器获取游戏服务器端口号</li>
<li>游戏服务器：每个容器启动一个游戏服务，启动多个容器映射不同端口</li>
</ul>
<p><strong>特点：</strong> 无需修改游戏服务器软件，登陆服务器通过管理容器实现管理游戏服务器。 </p>
<h2 id="1-4-">1.4结论</h2>
<p>使用方案3效果最优。</p>
<blockquote>
<p>那么问题来了，什么是容器？</p>
</blockquote>
<p><strong>容器：</strong> 是一种虚拟化技术，这种技术将操作系统内核虚拟化，可以允许用户空间软件实例（instances）被分割成几个独立的单元，在内核中运行，而不是只有一个单一实例运行。</p>
<p><strong>解释</strong>： 在操作系统和应用程序之间添加的一层：容器层。容器层对于操作系统来说，就是一个应用程序。容器层对于应用程序来说，好像一个操作系统。<img src="商业化部署.assets/容器运行时.png" alt="容器运行时"></p>
<ul>
<li>一个主机可以有多个相似或相同的容器</li>
<li>应用程序不知道自己运行在容器中。</li>
<li>docker是当前最主流的容器工具</li>
</ul>
<h2 id="1-5-">1.5计划</h2>
<ol>
<li>将游戏服务器放到docker容器中运行</li>
<li>登陆服务器管理多个容器并提供创建容器和查询容器的功能</li>
<li>登陆客户端发送用户命密码请求和房间创建或跟随请求，根据用户选择，启动游戏连接对应游戏服务器</li>
</ol>
<h1 id="2-docker">2 docker</h1>
<p>docker是一个实现容器技术的软件，用到了linux内核的命名空间原理。</p>
<h2 id="2-1-docker">2.1 初识docker</h2>
<p><strong>安装</strong></p>
<pre><code class="lang-bash"># 执行脚本简易安装
$ sudo apt-get install curl
$ curl -sSL https://get.daocloud.io/docker | sh
# 修改添加当前用户到docker用户组,修改socket权限
$ sudo usermod -aG docker dev
$ sudo chmod 777 /var/run/docker.sock
# 退出终端后再次进入测试命令
$ docker --hep
</code></pre>
<p><strong>第一次运行</strong></p>
<pre><code class="lang-bash">$ docker run hello-world
</code></pre>
<p><strong>运行详解：</strong></p>
<ol>
<li>The Docker client contacted the Docker daemon.</li>
<li>The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub (amd64)</li>
<li>The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading.</li>
<li><p>The Docker daemon streamed that output to the Docker client, which sent it to your terminal.</p>
</li>
<li><p>命令行连接到守护进程</p>
</li>
<li><p>守护进程发现当前没有hello-world镜像，于是去dockerhub下载了一个镜像</p>
</li>
<li>守护进程基于hello-world镜像创建了一个容器，容器内有一个可执行程序，现在的内容都是由该程序输出的。</li>
<li>守护进程将容器的输出发送给命令行，也就是当前终端。</li>
</ol>
<h2 id="2-2-docker-">2.2 docker详解</h2>
<p><strong>程序架构</strong></p>
<p>docker是CS架构的软件，命令行敲的命令会发送到一个守护进程docker Daemon执行。一般地，命令行和守护进程在同一个计算机运行。容器，镜像的管理由docker Daemon执行，命令行无需关心。</p>
<p><strong>核心概念</strong></p>
<p>docker有三个核心概念，镜像，容器和仓库。</p>
<h3 id="-">仓库</h3>
<p>类似github，docker官方设定了一个docker镜像的仓库：dockerhub（<a href="https://hub.docker.com/）">https://hub.docker.com/）</a></p>
<ul>
<li>本地计算机可以拉去dockerhub上的镜像</li>
</ul>
<pre><code class="lang-bash"># 完整的docker镜像名称是 作者/镜像名:标签
$ docker pull ubuntu/ubuntu:latest
</code></pre>
<ul>
<li>本地计算机的镜像可以推送到dockerhub的账户内</li>
</ul>
<pre><code class="lang-bash"># 登陆，按照提示输入github的用户名密码
$ docker login
# 将本地镜像重命名成规范名称
$ docker tag ubuntu marklion/ubuntu:myfirsttag
# 推送自己的镜像
$ docker push marklion/ubuntu:myfirsttag
</code></pre>
<ul>
<li>镜像的修改，提交等操作很类似git和github的操作。</li>
</ul>
<h3 id="-">镜像</h3>
<ul>
<li><strong>概念：</strong> 一组环境的静态集合，类似操作系统镜像。</li>
<li><strong>特点：</strong> docker镜像有分层依赖的关系。创建镜像的过程就好像写代码，从简单到复杂的过程。</li>
</ul>
<p><img src="商业化部署.assets/镜像分层.png" alt="镜像分层"></p>
<ul>
<li><strong>运行：</strong> 镜像运行后会产生容器。基于一个镜像可以运行多个容器。</li>
</ul>
<pre><code class="lang-bash"># 查看当前所有的镜像
$ docker images
# 运行ubuntu镜像：在ubuntu容器中执行一条ls的命令，不写命令则运行bash
$ docker run --rm -ti ubuntu ls
# --rm -ti参数：运行结束后删除容器，提供虚拟终端和交互式界面
</code></pre>
<ul>
<li><p><strong>创建：</strong> 类似基于原始系统搭环境</p>
<ul>
<li><p>手动创建</p>
<ol>
<li>下载并运行基础镜像</li>
<li>进入基础镜像的容器内安装所需环境</li>
<li>将容器提交为镜像</li>
</ol>
<pre><code class="lang-bash"># 直接执行ifconfig，报错，因为基础镜像没有安装ifconfig包
$ docker run --rm ubuntu ifconfig
docker: Error response from daemon: OCI runtime create failed: container_linux.go:344: starting container process caused &quot;exec: \&quot;ifconfig\&quot;: executable file not found in $PATH&quot;: unknown.
ERRO[0000] error waiting for container: context canceled 
# 进入基础镜像，安装工具包后退出
$ docker run -ti ubuntu
# apt-get update
# apt-get install -y net-tools
# exit
# 找到刚才的容器，基于其创建镜像
$ docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED          STATUS                      PORTS               NAMES
034abada670c        ubuntu              &quot;/bin/bash&quot;         31 minutes ago      Exited (0) 20 seconds ago                       zealous_swirles
# commit命令用于容器---》镜像
# 容器ID可以用简写
$ docker commit 034a my_unbuntu:add_net
$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
my_unbuntu          add_net             6ca02b1d0483        5 seconds ago       114MB
# 用新镜像运行ifconfig
$ docker run --rm my_unbuntu:add_net ifconfig
eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
    inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255
    ether 02:42:ac:11:00:02  txqueuelen 0  (Ethernet)
    RX packets 2  bytes 200 (200.0 B)
    RX errors 0  dropped 0  overruns 0  frame 0
    TX packets 0  bytes 0 (0.0 B)
    TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536
    inet 127.0.0.1  netmask 255.0.0.0
    loop  txqueuelen 1000  (Local Loopback)
    RX packets 0  bytes 0 (0.0 B)
    RX errors 0  dropped 0  overruns 0  frame 0
    TX packets 0  bytes 0 (0.0 B)
    TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</code></pre>
</li>
<li><p>脚本创建</p>
<ol>
<li>编写Dockerfile</li>
<li>运行docker编译命令</li>
</ol>
<pre><code class="lang-bash"># Dockerfile中定义基础镜像，和要运行的安装命令
$ cat Dockerfile
FROM ubuntu
RUN apt-get update
RUN apt-get install -y net-tools
# 编译镜像，指定镜像名是df_unbutu:add_net，指定Dockerfile所在目录是当前目录
$ docker build -t df_unbutu:add_net .
</code></pre>
</li>
</ul>
<p><strong>小结：</strong> 手动创建方便操作，脚本创建方便分享。</p>
</li>
</ul>
<h3 id="-">容器</h3>
<ul>
<li><strong>概念：</strong> 运行中的一组环境。基于某个镜像创建。</li>
<li><strong>特点：</strong> 容器中要运行程序，最好只运行一个程序。容器的运行不会影响镜像内容。</li>
<li><p><strong>运行：</strong></p>
<ul>
<li>支持以后台模式运行进程</li>
<li>支持将容器内的端口映射到宿主机</li>
<li>支持以挂载的形式和宿主机共享文件系统</li>
<li>容器运行的程序退出后，容器随之退出；容器退出后可以再次打开</li>
</ul>
</li>
</ul>
<p>这是一个tcp回传服务器。</p>
<pre><code class="lang-c">  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;
  #include &lt;unistd.h&gt;
  #include &lt;sys/types.h&gt;
  #include &lt;sys/socket.h&gt;
  #include &lt;string.h&gt;
  #include &lt;errno.h&gt;
  #include &lt;netinet/in.h&gt;
  #include &lt;arpa/inet.h&gt;

    int main()
    {
        int listen_sock = socket(AF_INET, SOCK_STREAM, 0);
        if (0 &lt;= listen_sock)
        {
            struct sockaddr_in stServerAddr;
            stServerAddr.sin_family = AF_INET;
            stServerAddr.sin_addr.s_addr = htonl(INADDR_ANY);
            stServerAddr.sin_port = htons(55555);
            if ((0 == bind(listen_sock, (struct sockaddr *)&amp;stServerAddr, sizeof(stServerAddr))) &amp;&amp;
                (0 == listen(listen_sock, 10)))
            {
                struct sockaddr_in stClientAddr;
                socklen_t AddrLen = sizeof(stClientAddr);
                int data_sock = -1;
                while (0 &lt;= (data_sock = accept(listen_sock, (struct sockaddr *)&amp;stClientAddr, &amp;AddrLen)))
                {
                    char szBuff[256];
                    int recv_len = 0;
                    while (0 &lt; (recv_len = recv(data_sock, szBuff, sizeof(szBuff), 0)))
                    {
                        send(data_sock, szBuff, recv_len, 0);
                    }
                    close(data_sock);
                }
            }
            else
            {
                perror(&quot;bind:&quot;);
            }
        }
        else
        {
            perror(&quot;create listen socket:&quot;);
        }
        return -1;
    }
</code></pre>
<p>使用ubuntu镜像运行该程序：</p>
<pre><code class="lang-bash"># 启动容器，
# -d 以守护进程启动容器
# -v /home/dev/:/root/host/ 将本机的/home/dev/目录挂载到容器内的/root/host目录下
# -p 22334:55555 将本机的22334端口映射到容器内的55555端口
# /root/host/tcp_echo，可执行程序的路径
$ docker run -d -v /home/dev/:/root/host/ -p 22334:55555 ubuntu /root/host/tcp_echo
</code></pre>
<h3 id="-">使用约束</h3>
<ul>
<li>docker只能安装在64位linux系统上（或专业版win10）</li>
<li>docker官方推荐，在一个容器中最好只运行一个进程</li>
<li>镜像和容器会占用磁盘空间。好习惯：删除不用的容器和镜像</li>
</ul>
<h2 id="2-3-docker-">2.3 docker和虚拟机的对比</h2>
<p>相似处：</p>
<ul>
<li>都通过镜像包装</li>
<li>都可以起到隔离进程运行环境的作用</li>
</ul>
<p><strong>区别：</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>docker</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody>
<tr>
<td>速度</td>
<td>快（基于当前系统创建不同的运行上下文）</td>
<td>慢（启动操作系统）</td>
</tr>
<tr>
<td>体量</td>
<td>小（镜像文件可以自由定制裁剪）</td>
<td>大（依赖厂商决定）</td>
</tr>
<tr>
<td>分发</td>
<td>容易（dockerhub，Dockerfile）</td>
<td>困难（一般由厂商分发）</td>
</tr>
<tr>
<td>复杂度</td>
<td>简单（对于操作系统而言只是一个程序）</td>
<td>复杂（需要考虑资源分配，与宿主机的通信等问题）</td>
</tr>
<tr>
<td>独立性</td>
<td>较好（容器只能基于端口独立）</td>
<td>非常好（跟真实主机几乎没有区别）</td>
</tr>
</tbody>
</table>
<h2 id="2-4-docker-">2.4 常用docker命令</h2>
<table>
<thead>
<tr>
<th>类型</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>镜像操作</td>
<td>docker images</td>
<td>显示存在的当前镜像</td>
</tr>
<tr>
<td></td>
<td>docker image prune</td>
<td>删除无用的镜像（被更新的旧镜像）</td>
</tr>
<tr>
<td></td>
<td>docker rmi <em>镜像ID</em></td>
<td>删除指定的镜像</td>
</tr>
<tr>
<td></td>
<td>docker build -t <em>镜像名称：tag dockerfile所在路径</em></td>
<td>编译镜像</td>
</tr>
<tr>
<td></td>
<td>docker login</td>
<td>登陆dockerhub</td>
</tr>
<tr>
<td></td>
<td>docker pull <em>镜像作者/镜像名称：tag</em></td>
<td>从dockerhub拉取镜像</td>
</tr>
<tr>
<td></td>
<td>docker tag <em>镜像名称：tag</em> <em>镜像作者/新名称：tag</em></td>
<td>规范重命名镜像</td>
</tr>
<tr>
<td></td>
<td>docker push <em>镜像作者/镜像名称：tag</em></td>
<td>推送镜像到dockerhub</td>
</tr>
<tr>
<td>容器操作</td>
<td>docker ps -a</td>
<td>显示当前所有容器</td>
</tr>
<tr>
<td></td>
<td>docker rm <em>容器ID</em></td>
<td>删除指定容器，运行中容器不能删</td>
</tr>
<tr>
<td></td>
<td>docker start -ai <em>容器ID</em></td>
<td>启动之前退出的容器</td>
</tr>
<tr>
<td></td>
<td>docker stop <em>容器ID</em></td>
<td>停止指定容器</td>
</tr>
<tr>
<td></td>
<td>docker cp <em>宿主机文件绝对路径</em> <em>容器ID：容器内绝对路径</em></td>
<td>从宿主机拷贝文件到容器内</td>
</tr>
<tr>
<td></td>
<td>docker cp <em>容器ID：容器内绝对路径</em> <em>宿主机文件绝对路径</em></td>
<td>从容器内拷贝文件到宿主机</td>
</tr>
<tr>
<td>run命令</td>
<td>docker run _参数_ <em>镜像名</em> <em>执行程序名</em></td>
<td>创建并运行容器</td>
</tr>
<tr>
<td></td>
<td>-d</td>
<td>守护模式运行，适用服务，与ti参数互斥</td>
</tr>
<tr>
<td></td>
<td>-ti</td>
<td>打开终端交换模式，适用应用程序，与-d互斥</td>
</tr>
<tr>
<td></td>
<td>-v <em>主机绝对路径</em>:<em>容器内绝对路径</em></td>
<td>将宿主机路径挂载到容器内</td>
</tr>
<tr>
<td></td>
<td>-p <em>主机端口</em>:<em>容器内端口</em></td>
<td>将容器内端口映射到宿主机端口</td>
</tr>
<tr>
<td></td>
<td>-e <em>环境变量名=环境变量值</em></td>
<td>向容器内定义环境变量</td>
</tr>
<tr>
<td></td>
<td>--rm</td>
<td>容器退出后自动删除，适用纯应用程序</td>
</tr>
</tbody>
</table>
<p>更多：<code>man docker,man docker run .....</code></p>
<h2 id="2-5-dockerfile-">2.5 Dockerfile编写</h2>
<p><strong>编写思路</strong></p>
<ol>
<li>确定基础镜像</li>
<li>安装所需环境</li>
<li>定义执行点</li>
</ol>
<pre><code>FROM ubuntu
RUN apt-get update
RUN apt-get install -y gcc
ENTRYPOINT [&quot;gcc&quot;]
</code></pre><p>编译镜像，执行gcc</p>
<pre><code class="lang-bash">$ docker build -t my_gcc .
# 由于dockerfile中定义了执行点是gcc，所以，镜像名后所有内容都是gcc的参数
$ docker run -v /home/dev/:/root/host/ my_gcc /root/host/tcp_echo.c -o /root/host/tcp_echo 
</code></pre>
<p><strong>常见指令</strong></p>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>FROM <em>本地镜像名或dockerhub镜像名</em></td>
<td>指定基础镜像</td>
</tr>
<tr>
<td>WORKDIR <em>容器内绝对路径</em></td>
<td>指定后续容器内命令的执行路径</td>
</tr>
<tr>
<td>RUN <em>命令</em></td>
<td>构建镜像过程中执行的命令，多条可以顺序书写</td>
</tr>
<tr>
<td>COPY <em>主机文件路径</em> <em>容器内路径</em></td>
<td>将主机文件拷贝到容器内，主机文件必须使用dockerfile所在路径的相对路径</td>
</tr>
<tr>
<td>EXPOSE <em>端口号</em></td>
<td>定义要映射到主机的端口号，搭配run命令的-P参数可以随机映射</td>
</tr>
<tr>
<td>ENTRYPOINT <em>[&quot;程序&quot;]</em>或<em>脚本</em></td>
<td>定义镜像执行点，定义后，run命令的最后字段会变成该命令的参数</td>
</tr>
<tr>
<td>CMD <em>[&quot;命令或参数&quot;]</em></td>
<td>若没有定义执行点，则该命令定义的是镜像创建后缺省的指向程序。若定义了执行点，则该命令定义的是执行点的参数。run命令的最后字段会替换该命令的值</td>
</tr>
</tbody>
</table>
<h2 id="2-6-">2.6 将游戏服务器放到容器中运行</h2>
<p><strong>需求拆解：</strong> 在容器中运行游戏服务器总共分三步：</p>
<ol>
<li>为游戏服务器创建环境可用的镜像</li>
<li>把游戏服务器作为容器执行点并开放端口映射</li>
<li>以守护进程模式运行镜像</li>
</ol>
<p><strong>问题1</strong>：环境可用？我们的游戏服务器有哪些依赖？怎么解决</p>
<p><strong>解决方案：</strong> </p>
<ul>
<li>基于纯净ubuntu安装zinx库，安装protobuf</li>
<li>静态编译游戏服务器（推荐）</li>
</ul>
<p><strong>问题2</strong>：端口映射到哪个宿主机端口？映射端口时，宿主机端口会不会被占用？</p>
<p><strong>解决方案：</strong> run容器时使用-P配合dockerfile里的EXPOSE随机分配端口。</p>
<h3 id="-1-">步骤1 静态编译游戏服务器</h3>
<ul>
<li>修改zinx框架的Makefile，构建静态zinx库：libzinx.a</li>
</ul>
<pre><code class="lang-Makefile">libzinx.a:./channel/*.cpp ./message/*.cpp ./role/*.cpp ./protocol/*.cpp ./*.cpp
        g++ -c -std=c++11 -fPIC  $^ -I ./include
        ar -rc $@ *.o
</code></pre>
<ul>
<li>修改游戏服务器的Makefile，使用静态编译<ul>
<li>-static关键字表示静态编译。链接时会链接.a文件</li>
<li>-Wl,--whole-archive -lpthread -Wl,--no-whole-archive参数是为了解决gcc的一个bug，没有这一串参数时，pthread库的静态编译会有问题。</li>
</ul>
</li>
</ul>
<pre><code class="lang-Makefile">game:*.cpp
    g++ -g -std=c++11 -pthread -Wl,--whole-archive -lpthread -Wl,--no-whole-archive $^ -o $@ -lprotobuf -lzinx -pthread -static
</code></pre>
<p>此时，只要是64位linux系统，都可以运行该程序。</p>
<h3 id="-2-dockerfile">步骤2 编写Dockerfile</h3>
<p>基于ubuntu基础镜像，拷贝游戏服务器程序和相关文件;向外暴露8899端口;设定执行点为游戏服务器进程。</p>
<pre><code>FROM ubuntu
WORKDIR /root/
EXPOSE 8899
COPY game random* ./
CMD [&quot;debug&quot;]
ENTRYPOINT [&quot;./game&quot;]
</code></pre><h3 id="-3-">步骤3 测试</h3>
<ol>
<li>编译镜像</li>
<li>运行镜像，-d指定守护运行，-P指定端口随机映射</li>
<li>查看该容器映射的端口号，启动游戏测试</li>
</ol>
<pre><code class="lang-bash">$ docker build  -t game_run .
$ docker run -Pd game_run
$ docker ps 
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES
f8d541bc7917        game_run            &quot;./game debug&quot;      6 minutes ago       Up 6 minutes        0.0.0.0:32768-&gt;8899/tcp   confident_spence
</code></pre>
<p>用32768端口启动游戏客户端，测试OK</p>
<h1 id="3-nginx-fastcgi">3 Nginx+Fastcgi</h1>
<p>接下来我们创建登陆服务器，用于管理游戏容器，向客户端回复登陆是否成功，房间是否创建成功或房间是否可以跟随。</p>
<p><strong>特点：</strong></p>
<ul>
<li>效率要求低</li>
<li>每个客户端的请求都是独立处理的</li>
</ul>
<blockquote>
<p>这其实是典型的BS架构的服务器需求</p>
</blockquote>
<p><img src="商业化部署.assets/两种架构结构.png" alt="两种架构结构"></p>
<h2 id="3-1-http-">3.1 HTTP简介</h2>
<p><strong>为什么要用HTTP？</strong></p>
<p>服务器的开发不容易，尤其是开发高性能、稳定性好服务器，更加不容易，因此人们尝试更好简单的方式来开发软件。</p>
<p>在服务器方面，使用Web服务器，采用HTTP协议来代替底层的socket，是常见的选择。采用HTTP协议更加除了能得到稳定的服务器支持外，更加可以兼容各种客户端（手机、PC、浏览器）等等。这样实现了一个服务器之后，多个客户端可以通用。</p>
<p><img src="商业化部署.assets/HTTP通信过程.png" alt="HTTP通信过程"></p>
<p><strong>HTTP是什么？</strong></p>
<p>超文本传输协议(HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议，它详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。</p>
<p>HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。如下图所示：</p>
<p><img src="商业化部署.assets/HTTP协议分层.png" alt="HTTP协议分层"></p>
<p>HTTP协议的特点：</p>
<ul>
<li>支持C/S架构</li>
<li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径，常用方法：GET、POST</li>
<li>灵活：HTTP允许传输任意类型的数据对象</li>
<li>无连接：限制每次连接只处理一个请求</li>
<li>无状态：即如果后续处理需要前面的信息，它必须重传</li>
</ul>
<p><strong>实例：</strong></p>
<ol>
<li>打开Chrome浏览器，按下F12，弹出调试界面。</li>
<li>访问<code>http://www.12371.cn/</code>（中共中央组织部官网）</li>
<li>查看调试界面<img src="商业化部署.assets/一次http访问的过程.png" alt="一次http访问的过程"></li>
</ol>
<p><strong>小结</strong></p>
<p>HTTP是基于文本传输的通信协议。</p>
<ul>
<li><p>在请求报文中包含：</p>
<ul>
<li>请求的类型：GET或POST</li>
<li>请求的资源路径：Request URL</li>
<li>一些额外数据</li>
</ul>
</li>
<li><p>在回复报文中包含</p>
<ul>
<li>请求状态码：<code>Status Code: 200 OK</code></li>
<li>回复给浏览器的内容：html文件内容（静态网页），JS脚本（网页交互逻辑），媒体数据（图片等）</li>
<li>相关的额外数据</li>
</ul>
</li>
</ul>
<p>自己写http服务器不是好的选择。</p>
<p><strong>BS架构下典型的服务器模型：Nginx+Fastcgi</strong></p>
<h2 id="3-2-nginx">3.2 Nginx</h2>
<p><strong>什么是Nginx</strong></p>
<p>Nginx是一款轻量级的Web 服务器、反向代理服务器、电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。</p>
<p>由俄罗斯的程序设计师Igor Sysoev所开发，供俄国大型的入口网站及搜索引擎Rambler（俄文：Рамблер）使用。</p>
<p>其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p>
<p><strong>Nginx优势</strong></p>
<p>1)    更快
正常情况下单次请求得到更快的响应，高峰期(数以万计的并发时)Nginx可
以比其它web服务器更快的响应请求。</p>
<p>2)    高扩展性
低耦合设计的模块组成,丰富的第三方模块支持。</p>
<p>3)    高可靠性
经过大批网站检验，每个worker进程相对独立，master进程在一个worker 进程出错时，可以快速开启新的worker进程提供服务。</p>
<p>4)    低内存消耗
一般情况下，10000个非活跃的HTTP Keep-Alive连接在Nginx中仅消耗 2.5M内存，这是Nginx支持高并发的基础。</p>
<p>5)    单机支持10万以上的并发连接
取决于内存，10万远未封顶。</p>
<p>6)    热部署
master和worker的分离设计，可实现7x24小时不间断服务的前提下，升级Nginx可执行文件，当然也支持更新配置项和日志文件。</p>
<p>7)    最自由的BSD许可协议
BSD许可协议允许用户免费使用Nginx、修改Nginx源码，然后再发布。这吸引了无数的开发者继续为 Nginx贡献智慧。</p>
<p><strong>Nginx安装</strong></p>
<p><code>sudo apt-get install nginx</code></p>
<p>安装后的目录布局：</p>
<ul>
<li>可执行文件：<code>/usr/sbin/nginx</code></li>
<li>配置文件目录：<code>/etc/nginx/</code></li>
<li>网页范例目录：<code>/usr/share/nginx/</code></li>
<li>运行日志目录：<code>/var/log/nginx/</code></li>
</ul>
<p>一般地，Nginx要访问很多系统资源，所以，需要超级用户权限才能启动</p>
<p>测试：<code>sudo nginx -t</code>
启动：<code>sudo nginx</code>
停止: <code>sudo nginx -s stop</code>
重启：<code>sudo nginx -s reload</code></p>
<p><strong>Nginx配置方式</strong></p>
<p>Nginx配置文件结构：</p>
<p><img src="商业化部署.assets/Nginx配置结构.png" alt="Nginx配置结构"> </p>
<table>
<thead>
<tr>
<th>配置层次</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>main</td>
<td>Nginx在运行时与具体业务功能无关的参数，比如工作进程数、运行身份等</td>
</tr>
<tr>
<td>http</td>
<td>与提供http服务相关的参数，比如keepalive、gzip等</td>
</tr>
<tr>
<td>server</td>
<td>http服务上支持若干虚拟机，每个虚拟机一个对应的server配置项，配置项里包含该虚拟机相关的配置</td>
</tr>
<tr>
<td>location</td>
<td>http服务中，某些特定的URL对应的一系列配置项</td>
</tr>
<tr>
<td>mail</td>
<td>实现email相关的SMTP/IMAP/POP3代理时，共享的一些配置项</td>
</tr>
</tbody>
</table>
<p>配置文件的生效阶段：</p>
<p><img src="商业化部署.assets/Nginx工作流程.png" alt="Nginx工作流程"></p>
<p><strong>重点关注server配置项和location配置项</strong></p>
<p>通过不同的配置可以将nginx作为不同的角色使用。</p>
<h3 id="3-2-1-">3.2.1静态页面</h3>
<p>修改<code>/usr/share/nginx/html/index.html</code>为：</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;this is itcast&lt;/title&gt;
&lt;style&gt;
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;this is itcast&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>修改<code>/etc/nginx/nginx.conf</code>为</p>
<pre><code>user www-data;
worker_processes auto;
pid /run/nginx.pid;

events {
    worker_connections 768;
}

http {
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    server {
        listen 80 default_server;
        location / {
            root /usr/share/nginx/html;
            index index.html;
        }
    }
}
</code></pre><h3 id="3-2-2-">3.2.2反向代理</h3>
<p>在nginx.conf的server配置段添加：</p>
<pre><code>location /1/{
    proxy_pass http://www.baidu.com/;
}
location /2/{
    proxy_pass http://www.sina.com/;
}
</code></pre><p><img src="商业化部署.assets/反向代理示意图.png" alt="反向代理示意图"></p>
<h3 id="3-3-3fastcgi">3.3.3fastcgi</h3>
<p>fastcgi是用来处理动态请求的。当用户请求匹配到配置fastcgi的location时，请求会发给fastcgi程序处理。</p>
<p>添加如下配置段，意味着用户的每条请求都会封装成fastcgi标准的格式转发给127.0.0.1这台主机（本机）的12345端口。</p>
<pre><code>location /fcgi/{
    fastcgi_pass 127.0.0.1:12345;
}
</code></pre><p>服务器可以通过编写丰富的fastcgi程序和用户进行多种互动。</p>
<p>接下来我们看一下怎样使用fastcgi。</p>
<h2 id="3-3-cgi-fast-cgi">3.3 CGI和FAST-CGI</h2>
<h3 id="3-3-1-cgi">3.3.1 CGI</h3>
<p><strong>简介</strong></p>
<p>通用网关接口(Common Gateway Interface、CGI)描述了客户端和服务器程序之间传输数据
的一种标准，可以让一个客户端，从网页浏览器向执行在网络服务器上的程序请求数据。
CGI独立于任何语言的，CGI 程序可以用任何脚本语言或者是完全独立编程语言实现，只要这个语言可以在这个系统上运行。Unix shell script、Python、 Ruby、PHP、 perl、Tcl、 C/C++和 Visual Basic 都可以用来编写 CGI 程序。</p>
<p>最初，CGI 是在 1993 年由美国国家超级电脑应用中心(NCSA)为 NCSA HTTPd Web 服务
器开发的。这个 Web 服务器使用了 UNIX shell 环境变量来保存从 Web 服务器传递出去的参数，然后生成一个运行 CGI 的独立的进程。</p>
<p><strong>CGI处理流程</strong></p>
<ol>
<li>web服务器收到客户端(浏览器)的请求Http Request，启动CGI程序，并通过环境变量、标准输入传递数据</li>
<li>CGI进程启动解析器、加载配置(如业务相关配置)、连接其它服务器(如数据库服务器)、逻辑处理等</li>
<li>CGI进程将处理结果通过标准输出、标准错误，传递给web服务器</li>
<li>web服务器收到CGI返回的结果，构建Http Response返回给客户端，并杀死CGI进程</li>
</ol>
<p><img src="商业化部署.assets/cgi运行流程.png" alt="cgi运行流程"></p>
<p>web服务器与CGI通过环境变量、标准输入、标准输出、标准错误互相传递数据。在遇到用户连接请求：</p>
<ul>
<li>先要创建CGI子进程，然后CGI子进程处理请求，处理完事退出这个子进程：fork-and-execute</li>
<li>CGI方式是客户端有多少个请求，就开辟多少个子进程，每个子进程都需要启动自己的解释器、加载配置，连接其他服务器等初始化工作，这是CGI进程性能低下的主要原因。当用户请求非常多的时候，会占用大量的内存、cpu等资源，造成性能低下。</li>
</ul>
<p>CGI使外部程序与Web服务器之间交互成为可能。CGI程序运行在独立的进程中，并对每个Web请求建立一个进程，这种方法非常容易实现，但效率很差，难以扩展。面对大量请
求，进程的大量建立和消亡使操作系统性能大大下降。此外，由于地址空间无法共享，也限
制了资源重用。</p>
<p><strong>环境变量</strong>
GET请求，它将数据打包放置在环境变量QUERY_STRING中，CGI从环境变量
QUERY_STRING中获取数据。</p>
<p>常见的环境变量如下表所示：</p>
<table>
<thead>
<tr>
<th>环境变量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>AUTH_TYPE</td>
<td>存取认证类型</td>
</tr>
<tr>
<td>CONTENT_LENGTH</td>
<td>由标准输入传递给CGI程序的数据长度，以bytes或字元数来计算</td>
</tr>
<tr>
<td>CONTENT_TYPE</td>
<td>请求的MIME类型</td>
</tr>
<tr>
<td>GATEWAY_INTERFACE</td>
<td>服务器的CGI版本编号</td>
</tr>
<tr>
<td>HTTP_ACCEPT</td>
<td>浏览器能直接接收的Content-types, 可以有HTTP Accept header定义</td>
</tr>
<tr>
<td>HTTP_USER_AGENT</td>
<td>递交表单的浏览器的名称、版本和其他平台性的附加信息</td>
</tr>
<tr>
<td>HTTP_REFERER</td>
<td>递交表单的文本的URL，不是所有的浏览器都发出这个信息，不要依赖它</td>
</tr>
<tr>
<td>PATH_INFO</td>
<td>传递给CGI程序的路径信息</td>
</tr>
<tr>
<td>QUERY_STRING</td>
<td>传递给CGI程序的请求参数，也就是用&quot;?&quot;隔开，添加在URL后面的字串</td>
</tr>
<tr>
<td>REMOTE_ADDR</td>
<td>client端的host名称</td>
</tr>
<tr>
<td>REMOTE_HOST</td>
<td>client端的IP位址</td>
</tr>
<tr>
<td>REMOTE_USER</td>
<td>client端送出来的使用者名称</td>
</tr>
<tr>
<td>REMOTE_METHOD</td>
<td>client端发出请求的方法(如get、post)</td>
</tr>
<tr>
<td>SCRIPT_NAME</td>
<td>CGI程序所在的虚拟路径，如/cgi-bin/echo</td>
</tr>
<tr>
<td>SERVER_NAME</td>
<td>server的host名称或IP地址</td>
</tr>
<tr>
<td>SERVER_PORT</td>
<td>收到request的server端口</td>
</tr>
<tr>
<td>SERVER_PROTOCOL</td>
<td>所使用的通讯协定和版本编号</td>
</tr>
<tr>
<td>SERVER_SOFTWARE</td>
<td>server程序的名称和版本</td>
</tr>
</tbody>
</table>
<p><strong>标准输入</strong>
环境变量的大小是有一定的限制的，当需要传送的数据量大时，储存环境变量的空间可能会
不足，造成数据接收不完全，甚至无法执行CGI程序。</p>
<p>因此后来又发展出另外一种方法：POST，也就是利用I/O重新导向的技巧，让CGI程序可以由stdin和stdout直接跟浏览器沟通。</p>
<p>当我们指定用这种方法传递请求的数据时，web服务器收到数据后会先放在一块输入缓冲区
中，并且将数据的大小记录在CONTENT_LENGTH这个环境变量，然后调用CGI程序并将
CGI程序的stdin指向这块缓冲区，于是我们就可以很顺利的通过stdin和环境变数CONTENT_LENGTH得到所有的信息，再没有信息大小的限制了。</p>
<p><strong>CGI程序结构</strong></p>
<p><img src="商业化部署.assets/CGI程序流程图.png" alt="CGI程序流程图"></p>
<h3 id="3-3-2fastcgi">3.3.2FastCGI</h3>
<p><strong>什么是FastCGI</strong></p>
<p>快速通用网关接口(Fast Common Gateway Interface／FastCGI)是通用网关接口(CGI)的改进，描述了客户端和服务器程序之间传输数据的一种标准。</p>
<p>FastCGI致力于减少Web服务器与CGI程式之间互动的开销，从而使服务器可以同时处理更多的Web请求。与为每个请求创建一个新的进程不同，FastCGI使用持续的进程来处理一连串的请求。这些进程由FastCGI进程管理器管理，而不是web服务器。</p>
<p><strong>FastCGI处理流程</strong></p>
<ol>
<li>Web 服务器启动时载入初始化FastCGI执行环境。 例如IIS、ISAPI、apache mod_fastcgi、nginx ngx_http_fastcgi_module、lighttpd mod_fastcgi。</li>
<li>FastCGI进程管理器自身初始化，启动多个CGI解释器进程并等待来自Web服务器的连接。启动FastCGI进程时，可以配置以ip和UNIX 域socket两种方式启动。</li>
<li>当客户端请求到达Web 服务器时， Web 服务器将请求采用socket方式转发FastCGI主进程，FastCGI主进程选择并连接到一个CGI解释器。Web 服务器将CGI环境变量和标准输入发送到FastCGI子进程。</li>
<li>FastCGI子进程完成处理后将标准输出和错误信息从同一socket连接返回Web 服务器。当FastCGI子进程关闭连接时，请求便处理完成。</li>
<li>FastCGI子进程接着等待并处理来自Web 服务器的下一个连接。</li>
</ol>
<p><img src="商业化部署.assets/fastcgi执行流程.png" alt="fastcgi执行流程"></p>
<p>由于FastCGI程序并不需要不断的产生新进程，可以大大降低服务器的压力并且产生较高的应用效率。它的速度效率最少要比CGI 技术提高 5 倍以上。它还支持分布式的部署，即
FastCGI 程序可以在web 服务器以外的主机上执行。</p>
<p>CGI 是所谓的短生存期应用程序，FastCGI 是所谓的长生存期应用程序。FastCGI
像是一个常驻(long-live)型的CGI，它可以一直执行着，不会每次都要花费时间去fork一次(这是CGI最为人诟病的fork-and-execute 模式)。</p>
<p><strong>FastCGI程序结构</strong></p>
<p><img src="商业化部署.assets/FastCGI程序流程图.png" alt="FastCGI程序流程图"></p>
<p><strong>FCGI库和spawn-cgi</strong></p>
<p>上图可以看出，fast-cgi程序和cgi程序的相似度很大，但又不完全相同。fcgi库的出现统一了两者。</p>
<p>fcgi是开发FastCGI程序常用的一个函数库：<a href="https://github.com/FastCGI-Archives/fcgi2.git">https://github.com/FastCGI-Archives/fcgi2.git</a></p>
<ul>
<li>fcgi库把socket数据收发和编结FastCGI数据封装成函数。方便开发者着眼于业务处理。</li>
<li>fcgi库在解析完FastCGI数据后会将模拟CGI的规范，设置环境变量和重定向标准输入。</li>
<li>利用fcgi编写的程序也可以当做cgi程序运行。</li>
</ul>
<p>这个fastcgi程序完成了一个返回客户端IP地址的功能。</p>
<pre><code class="lang-c">#include &lt;stdlib.h&gt;
#include &lt;fcgi_stdio.h&gt;

int main()
{
    while (FCGI_Accept() &gt;= 0)
    {
        printf(&quot;Content-Type:text\r\n\r\n&quot;);
        printf(&quot;clint ip is %s\r\n&quot;, getenv(&quot;REMOTE_ADDR&quot;));

    }

    return 0;
}
</code></pre>
<p>上边的代码中并没有体现守护进程和socket收发数据，所以我们需要借助一个fastcgi程序的管理器帮助。spawn-fcgi是一个通用的选择（apt下载安装）。</p>
<p>命令<code>spawn-fcgi -a 127.0.0.1 -p 7777 -f test-cgi</code>的意思是：按照守护模式启动test-cgi程序，并且监听本地地址（127.0.0.1）的7777端口。</p>
<h2 id="3-4-">3.4 组合使用</h2>
<p><strong>需求：</strong> 用户访问<a href="http://XXXXXXXXX/ip时，显示用户的IP">http://XXXXXXXXX/ip时，显示用户的IP</a></p>
<p><strong>步骤：</strong></p>
<ol>
<li>使用fcgi库编写FastCGI程序（上边的例子）。编译成可执行文件test-cgi</li>
<li>执行<code>spawn-fcgi -a 127.0.0.1 -p 7777 -f test-cgi</code>启动FastCgi程序。</li>
<li>在nginx配置文件中增加如下配置后重启nginx（nginx -s  reload）</li>
</ol>
<pre><code>location /cgi/ {
    include /etc/nginx/fastcgi_params;
    fastcgi_pass 127.0.0.1:7777;
}
</code></pre><h2 id="3-5-">3.5 开发技巧</h2>
<ul>
<li><p>使用fcgi库时的三要素：</p>
<ul>
<li><code>while (FCGI_Accept() &gt;= 0)</code>循环内写业务</li>
<li>用<code>getenv</code>和<code>fread(buf, sizeof(buf), 1, stdin)</code>获取用户的请求</li>
<li><p>用<code>printf</code>向用户展示数据；数据格式是</p>
<ul>
<li>若干行回复数据头（最简形式<code>Content-Type:text\r\n</code>）</li>
<li>一个空行</li>
<li>回复数据体</li>
</ul>
</li>
</ul>
</li>
<li><p>spawn-cgi启动fastcgi程序时要和nginx的fastcgi_pass配置项对应好</p>
</li>
<li>良好的设计是：不同目的的请求用不同的FastCGI程序处理。</li>
</ul>
<h1 id="4-qt-">4 Qt游戏登陆器</h1>
<h2 id="4-1-">4.1 关键技术</h2>
<h3 id="4-1-1http-">4.1.1http网络访问</h3>
<p><code>QNetworkAccessManager</code>,<code>QNetworkRequest</code>和<code>QNetworkReply</code>这三个类是Qt在网络访问比较常用的类。</p>
<p><strong>使用步骤：</strong></p>
<ol>
<li>创建QNetworkAccessManager对象</li>
<li>创建QNetworkRequest对象，并用setXXX的方法，设置http的请求头或请求数据</li>
<li>调用QNetworkAccessManager对象的post或get方法，将请求发出去。函数返回一个QNetworkReply对象。</li>
<li>将第3步的QNetworkReply对象的finish信号绑定到一个槽函数。</li>
<li>在槽函数中通过QNetworkReply的readAll函数可以读取到服务器的响应数据</li>
</ol>
<h3 id="4-1-2json-">4.1.2Json数据解析</h3>
<p><code>QJsonDocument</code>, <code>QJsonArray</code>和 <code>QJsonObject</code>这三个类在解析Json数据时比较常用</p>
<p><strong>使用步骤</strong>：</p>
<ol>
<li>使用QJsonDocument创建整体的Json数据对象</li>
<li>调用QJsonDocument的array函数可以返回QJsonArray的对象</li>
<li>遍历QJsonArray对象可以取出QJsonObject对象</li>
<li>操作符[]可以访问指定的key所对应的值</li>
</ol>
<h3 id="4-1-3-">4.1.3 启动外部进程</h3>
<p><code>QProcess</code> 用于启动外部程序</p>
<p><code>startDetached</code>成员函数可以启动程序，并且跟被启动的程序脱离父子关系。</p>
<h3 id="4-1-4-">4.1.4生成数字签名</h3>
<p><code>QCryptographicHash</code>类用来将原始时间生成数字签名。</p>
<p><strong>使用步骤</strong>：</p>
<ol>
<li>构造某个算法的签名生成器</li>
<li>添加原始数据到生成器中</li>
<li>调用生成函数得到数字签名</li>
</ol>
<h2 id="4-2-">4.2详细需求</h2>
<ul>
<li>用户点击跟房后，发送输入的用户名和密码和要跟随的房间号给登陆服务器</li>
<li>服务器会回复登陆结果和跟房结果</li>
<li>若登陆成功且跟房成功则启动游戏程序否则弹出提示信息</li>
<li>用户点击建房后，发送用户名密码给登陆服务器</li>
<li>若登陆成功且建房成功则提示房间号并启动游戏</li>
<li>用户点击注册后弹出浏览器并显示注册页面</li>
</ul>
<h2 id="4-3-">4.3实现</h2>
<pre><code class="lang-c++">#include &quot;mainwindow.h&quot;
#include &quot;ui_mainwindow.h&quot;
#include &lt;QJsonArray&gt;
#include &lt;QJsonDocument&gt;
#include &lt;QJsonObject&gt;
#include &lt;QMessageBox&gt;
#include &lt;QDialogButtonBox&gt;
#include &lt;QProcess&gt;

MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui-&gt;setupUi(this);
}

MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::TriggerLogin(QString _username, QString _password)
{
    QJsonObject oJson;
    oJson[&quot;username&quot;] = _username;
    oJson[&quot;password&quot;] = _password;
    if (0 == CurLoginStatus)
    {
        oJson[&quot;opt&quot;] = &quot;create&quot;;
    }
    else
    {
        oJson[&quot;opt&quot;] = &quot;follow&quot;;
        oJson[&quot;roomnum&quot;] = m_RoomNum;
    }
    QJsonDocument oJsonDoc(oJson);
    QString szOut = oJsonDoc.toJson();

    QNetworkRequest req(QUrl(&quot;http://192.168.64.142/login/&quot;));
    req.setHeader(QNetworkRequest::ContentTypeHeader,&quot;application/json&quot;);
    req.setHeader(QNetworkRequest::ContentLengthHeader,szOut.size());
    m_reply = m_AccMng.post(req,szOut.toUtf8());
    connect(m_reply, SIGNAL(finished()), this, SLOT(ProcLoginResult()));
}
void MainWindow::StartGame(int _RoomNum)
{
    //启动游戏进程，传递游戏服务器IP和端口号
    QStringList szArg;

    //设置ip和端口号到szArg
    szArg.push_back(&quot;192.168.64.142&quot;);
    szArg.push_back(QString::number(_RoomNum));

    QString szExePath = &quot;client.exe&quot;;
    QProcess oP;
    oP.setProgram(szExePath);
    oP.setArguments(szArg);
    oP.startDetached();
    qApp-&gt;exit();
}
void MainWindow::ProcLoginResult()
{
    /*接收登陆请求的回复*/
    QByteArray oInput = m_reply-&gt;readAll();
    QJsonDocument oJsonDoc = QJsonDocument::fromJson(oInput);
    /*从json对象中取出登陆结果*/
    QString szRes = oJsonDoc.object()[&quot;result&quot;].toString();

    if (&quot;yes&quot; == szRes)
    {
        if (0 == CurLoginStatus)
        {
            int RoomNum = oJsonDoc.object()[&quot;opt_ret&quot;].toInt();
            QMessageBox::information(this,&quot;房间创建成功&quot;,QString::number(RoomNum));
            StartGame(RoomNum);
        }
        else
        {
            if (&quot;yes&quot; == oJsonDoc.object()[&quot;opt_ret&quot;].toString())
            {
                StartGame(m_RoomNum);
            }
            else
            {
                QMessageBox::information(this,&quot;失败&quot;,&quot;房间不存在&quot;);
            }
        }
    }
    else
    {
        /*弹出登陆失败窗口*/
        QMessageBox::information(this, &quot;登陆失败&quot;, &quot;用户名或密码错误&quot;);
    }
}


void MainWindow::on_pushButton_2_clicked()
{
    CurLoginStatus = 0;

    /*读取用户输入*/
    QString szUsername = ui-&gt;UserName-&gt;text();
    QString szPassword = ui-&gt;Password-&gt;text();

    /*组织json数据*/
    /*换算密码hash值*/
    QCryptographicHash hash_creator(QCryptographicHash::Md5);
    /*设置源数据，生成hash数据*/
    hash_creator.addData(szPassword.toUtf8());
    szPassword = QString(hash_creator.result().toHex()); //szPassword变成密码hash值了
    TriggerLogin(szUsername, szPassword);
}

void MainWindow::on_pushButton_3_clicked()
{
    CurLoginStatus = 1;
    m_RoomNum = ui-&gt;RoomNum-&gt;text().toInt();
    /*读取用户输入*/
    QString szUsername = ui-&gt;UserName-&gt;text();
    QString szPassword = ui-&gt;Password-&gt;text();

    /*组织json数据*/
    /*换算密码hash值*/
    QCryptographicHash hash_creator(QCryptographicHash::Md5);
    /*设置源数据，生成hash数据*/
    hash_creator.addData(szPassword.toUtf8());
    szPassword = QString(hash_creator.result().toHex()); //szPassword变成密码hash值了
    TriggerLogin(szUsername, szPassword);
}
void MainWindow::on_pushButton_clicked()
{
    QDesktopServices::openUrl(QUrl(&quot;http://192.168.64.142/reg.html&quot;));
}
</code></pre>
<h1 id="5-">5登陆服务器</h1>
<p><strong>需求和设计</strong>：</p>
<ol>
<li>提供一个静态页面让用户填注册信息</li>
<li>提供一个fast-CGI程序用于处理用户的注册请求</li>
<li>提供一个fast-cgi程序用于处理用户的登陆，建房，跟房的请求</li>
</ol>
<p>问题1：怎样用C程序创建容器？</p>
<p>答：写shell脚本，在CGI程序中通过popen调用脚本</p>
<p>问题2：怎样存储用户名密码等数据</p>
<p>答：简单地，可以存文件（<code>用户名:密码的数字签名</code>的形式）</p>
<p><strong>实现</strong></p>
<h2 id="5-1-">5.1静态登陆页面及配置</h2>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;zh-CN&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;注册界面&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;form action=&quot;reg/&quot; method=&quot;post&quot; accept-charset=&quot;UTF-8&quot; enctype=&quot;text/plane&quot;&gt;
         &lt;input name=&quot;username&quot; type=&quot;text&quot; placeholder=&quot;用户名&quot;&gt;
         &lt;input name=&quot;password&quot; type=&quot;password&quot; placeholder=&quot;密码&quot;&gt;
         &lt;input type=&quot;submit&quot; id=&quot;submit&quot; value=&quot;提交&quot;&gt;
    &lt;/body&gt;
</code></pre>
<pre><code>server {
        listen 80;
        location / {
            root /usr/share/nginx/html/;
            index index.html;

        }
        location /login/ {
            include /etc/nginx/fastcgi_params;
            fastcgi_pass 127.0.0.1:8888;

        }
        location /reg/ {
            include /etc/nginx/fastcgi_params;
            fastcgi_pass 127.0.0.1:9999;

        }

    }
</code></pre><h2 id="5-2-cgi-">5.2添加用户的脚本和CGI程序</h2>
<pre><code class="lang-shell">#!/bin/bash
#Add_user.sh
USERNAME=&quot;$1&quot;
PASSWORD=&quot;$2&quot;

cat userfile | awk -F &quot;:&quot; &#39;{print $1}&#39; | grep -w &quot;${USERNAME}&quot;
if [ $? -ne 0  ]
then
    echo &quot;${USERNAME}:`echo -n ${PASSWORD} | openssl dgst -md5 -hex | awk &#39;{print $2}&#39;`&quot; &gt;&gt; userfile
    exit $?
fi

exit -1
</code></pre>
<pre><code class="lang-c++">#include &quot;CJsonObject.hpp&quot;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;fcgi_stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

using namespace std;

int main()
{
    while (FCGI_Accept() &gt;= 0)
    {
        neb::CJsonObject oOut;
        bool bFound = false;

        int iContentLength = atoi(getenv(&quot;CONTENT_LENGTH&quot;));
        char *pcBuff = (char *)calloc(1UL, iContentLength + 1);
        if (NULL != pcBuff)
        {
            fread(pcBuff, 1, iContentLength, stdin);
            pcBuff[iContentLength] = 0;

            char *pcUserName = (char *)calloc(1UL, iContentLength);
            char *pcPassword = (char *)calloc(1UL, iContentLength);

            sscanf(strtok(pcBuff, &quot;&amp;&quot;), &quot;username=%s&quot;, pcUserName);
            sscanf(strtok(NULL, &quot;&amp;&quot;), &quot;password=%s&quot;, pcPassword);

            if (0 == fork())
            {
                execlp(&quot;./Add_user.sh&quot;, &quot; &quot;, pcUserName, pcPassword, NULL );
                perror(&quot;exec&quot;);
                exit(1);

            }
            else
            {
                int iAddRes;
                wait(&amp;iAddRes);
                if (0 == iAddRes)
                {
                    printf(&quot;Content-Type:text\r\n\r\n&quot;);
                    printf(&quot;OK\r\n&quot;);

                }
                else
                {
                    printf(&quot;Content-Type:text\r\n\r\n&quot;);
                    printf(&quot;User exists\r\n&quot;);

                }


            }

            free(pcUserName);
            free(pcPassword);

            free(pcBuff);

        }


    }

}
</code></pre>
<h2 id="5-3-cgi-">5.3 容器查询，容器创建脚本和登陆CGI程序</h2>
<pre><code class="lang-shell">#!/bin/bash
#room_check.sh
docker ps -f ancestor=game:v1.0 | grep &quot;$1&quot; 2&gt;&amp;1 &gt;/dev/null
if [ 0 -eq $? ]
then
    echo &quot;yes&quot;
else
    echo &quot;no&quot;
fi
</code></pre>
<pre><code class="lang-shell">#!/bin/bash
#game_create.sh
docker run -d -P --rm game:v1.0 2&gt;&amp;1 &gt; /dev/null
docker ps -n 1 | grep 8899 | awk -F &quot;-&gt;&quot; &#39;{print $1}&#39; | awk -F : &#39;{print $NF}&#39;
</code></pre>
<pre><code class="lang-c++">#include &quot;CJsonObject.hpp&quot;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;fcgi_stdio.h&gt;
#include &lt;stdlib.h&gt;

using namespace std;

int exec_create()
{
    int iRet = -1;
    FILE *pret = popen(&quot;./game_create.sh&quot;, &quot;r&quot;);
    if (NULL != pret)
    {
        char retbuff[64];
        fread(retbuff, 1, sizeof(retbuff), pret);
        iRet = atoi(retbuff);
        pclose(pret);
    }

    return iRet;
}
void exec_follow(int room_num, char *pCheck)
{
    char cmd[128] = {0};

    sprintf(cmd, &quot;./room_check.sh %d&quot;, room_num);
    FILE *pret = popen(cmd, &quot;r&quot;);
    if (NULL != pret)
    {
        fread(pCheck, 1, 3, pret);
        pclose(pret);
    }
}


int main()
{
    while (FCGI_Accept() &gt;= 0)
    {
        neb::CJsonObject oOut;
        bool bFound = false;

        int iContentLength = atoi(getenv(&quot;CONTENT_LENGTH&quot;));
        char *pcBuff = (char *)calloc(1UL, iContentLength);
        if (NULL != pcBuff)
        {
            fread(pcBuff, 1, iContentLength, stdin);
            neb::CJsonObject oIn(string(pcBuff, iContentLength));

            string szUserName;
            oIn.Get(&quot;Username&quot;, szUserName);
            string szPassword_md5;
            oIn.Get(&quot;Password&quot;, szPassword_md5);

            ifstream fUserfile;
            fUserfile.open(&quot;userfile&quot;);
            if (fUserfile.is_open())
            {
                string szSingleLine;
                string szUserData = szUserName + &quot;:&quot; + szPassword_md5;
                while (getline(fUserfile, szSingleLine))
                {
                    if (szSingleLine == szUserData)
                    {
                        oOut.Add(&quot;result&quot;, &quot;yes&quot;);
                        bFound = true;

                        string szOpt;
                        oIn.Get(&quot;opt&quot;, szOpt);
                        if (&quot;create&quot; == szOpt)
                        {
                            int room_num = exec_create();
                            if (-1 != room_num)
                            {
                                oOut.Add(&quot;opt_ret&quot;, room_num);
                            }
                        }
                        else
                        {
                            int room_num;
                            oIn.Get(&quot;roomnum&quot;, room_num);
                            char szCheckRet[64] = {0};
                            exec_follow(room_num, szCheckRet);
                            oOut.Add(&quot;opt_ret&quot;, szCheckRet);
                        }
                        break;
                    }

                }
                fUserfile.close();

            }

            free(pcBuff);

        }

        if (false == bFound)
        {
            oOut.Add(&quot;result&quot;, &quot;no&quot;);

        }

        printf(&quot;Content-Type:application/json\r\nContent-Length:%d\r\n\r\n&quot;, oOut.ToFormattedString().size());
        printf(&quot;%s\r\n&quot;, oOut.ToFormattedString().c_str());


    }

}
</code></pre>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>